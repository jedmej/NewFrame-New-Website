---
import type { Lang } from '../../i18n/translations';
import { useTranslations } from '../../i18n/translations';

interface Props {
  lang: Lang;
}

const { lang } = Astro.props;
const t = useTranslations(lang);
---

<section
  id="hero"
  class="relative w-full h-screen flex flex-col justify-center items-center overflow-hidden"
  style="background-color: var(--color-bg);"
>
  <!-- Main content -->
  <div class="relative w-full h-full px-6 md:px-10 flex flex-col justify-center max-w-[2000px] mx-auto">

    <!-- Title — centered, dominant -->
    <div class="flex flex-col items-center justify-center">
      <h1
        id="hero-title"
        class="text-display-xl text-center text-[var(--color-text)] select-none"
        aria-label={t.hero.title}
      >
        {t.hero.title}
      </h1>
    </div>

    <!-- Corner metadata: top -->
    <div class="absolute top-[15%] left-[8%] right-[8%] flex flex-col items-center gap-2 md:flex-row md:justify-between md:items-start">
      <!-- Top-left: availability -->
      <div id="hero-corner-tl" class="flex items-center gap-2 opacity-0">
        <span class="w-1.5 h-1.5 rounded-full bg-[#5a9a6a] animate-pulse"></span>
        <span class="text-mono-xs text-[var(--color-text-subtle)]">{t.hero.available}</span>
      </div>
      <!-- Top-right: location -->
      <div id="hero-corner-tr" class="opacity-0">
        <span class="text-mono-xs text-[var(--color-text-subtle)]">{t.hero.location}</span>
      </div>
    </div>

    <!-- Corner metadata: bottom -->
    <div class="absolute bottom-[15%] left-[8%] right-[8%] flex flex-col items-center gap-2 md:flex-row md:justify-between md:items-end">
      <!-- Bottom-left: descriptor -->
      <div id="hero-corner-bl" class="opacity-0">
        <span class="text-mono-xs text-[var(--color-text-subtle)]">{t.hero.descriptor}</span>
      </div>
      <!-- Bottom-right: credit -->
      <div id="hero-corner-br" class="opacity-0">
        <span class="text-mono-xs text-[var(--color-text-subtle)]">{t.hero.credit}</span>
      </div>
    </div>
  </div>
</section>

<script>
  import gsap from 'gsap';
  import { SplitText } from 'gsap/SplitText';
  import { ScrollTrigger } from 'gsap/ScrollTrigger';

  gsap.registerPlugin(SplitText, ScrollTrigger);

  let cleanupFn: (() => void) | null = null;

  function initHero() {
    cleanupFn?.();
    cleanupFn = null;

    const titleEl = document.getElementById('hero-title');
    if (!titleEl) return;

    const ac = new AbortController();
    const { signal } = ac;
    const scrollTriggers: ScrollTrigger[] = [];
    const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;

    // Split title into characters
    const split = new SplitText(titleEl, {
      type: 'chars',
      charsClass: 'split-char',
    });

    const corners = [
      document.getElementById('hero-corner-tl'),
      document.getElementById('hero-corner-tr'),
      document.getElementById('hero-corner-bl'),
      document.getElementById('hero-corner-br'),
    ].filter(Boolean);

    let entranceTl: gsap.core.Timeline | null = null;

    // Scroll-driven animations — created only after corners are visible
    // so GSAP captures opacity:1 as the base state for correct reversal
    function setupScrollAnimations() {
      if (prefersReducedMotion) return;

      if (split.chars && split.chars.length > 0) {
        split.chars.forEach((char: HTMLElement, i: number) => {
          const offset = (i - split.chars.length / 2) * 6;
          const tween = gsap.to(char, {
            x: offset,
            opacity: 0.25,
            scrollTrigger: {
              trigger: '#hero',
              start: 'top top',
              end: 'bottom top',
              scrub: 1,
            },
          });
          if (tween.scrollTrigger) scrollTriggers.push(tween.scrollTrigger);
        });
      }

      if (corners.length > 0) {
        const cornerTween = gsap.to(corners, {
          y: -24,
          opacity: 0.6,
          scrollTrigger: {
            trigger: '#hero',
            start: 'top top',
            end: 'bottom top',
            scrub: 1,
          },
        });
        if (cornerTween.scrollTrigger) scrollTriggers.push(cornerTween.scrollTrigger);
      }

      const skewTo = gsap.quickTo(titleEl, 'skewY', { duration: 0.6, ease: 'power3.out' });
      const clamp = gsap.utils.clamp(-6, 6);
      const skewTrigger = ScrollTrigger.create({
        trigger: '#hero',
        start: 'top bottom',
        end: 'bottom top',
        onUpdate: (self) => {
          skewTo(clamp(self.getVelocity() / -650));
        },
      });
      scrollTriggers.push(skewTrigger);

      const fadeTween = gsap.to('#hero', {
        opacity: 0,
        scale: 0.98,
        scrollTrigger: {
          trigger: '#hero',
          start: '60% top',
          end: 'bottom top',
          scrub: 1,
        },
      });
      if (fadeTween.scrollTrigger) scrollTriggers.push(fadeTween.scrollTrigger);
    }

    const alreadyLoaded = localStorage.getItem('preloaded');

    if (alreadyLoaded) {
      // View transition or revisit — show immediately, then set up scrub
      gsap.set(split.chars, { opacity: 1, y: 0, rotateX: 0 });
      gsap.set(corners, { opacity: 1, y: 0 });
      setupScrollAnimations();
    } else {
      // First load — wait for preloader, then set up scrub on completion
      function playEntrance() {
        if (prefersReducedMotion) {
          gsap.set(split.chars, { opacity: 1, y: 0, rotateX: 0 });
          gsap.set(corners, { opacity: 1, y: 0 });
          setupScrollAnimations();
          return;
        }

        entranceTl = gsap.timeline({ onComplete: setupScrollAnimations });

        entranceTl.from(split.chars, {
          yPercent: 120,
          opacity: 0,
          rotateX: -80,
          stagger: { each: 0.025, from: 'center' },
          duration: 1.1,
          ease: 'power4.out',
        });

        entranceTl.to(corners, {
          opacity: 1,
          y: 0,
          duration: 0.8,
          stagger: 0.1,
          ease: 'power2.out',
        }, '-=0.3');
      }

      document.addEventListener('preloader:complete', playEntrance, { once: true, signal });
    }

    cleanupFn = () => {
      ac.abort();
      entranceTl?.kill();
      scrollTriggers.forEach((st) => st.kill());
      split.revert();
    };
  }

  initHero();
  document.addEventListener('astro:after-swap', initHero);
</script>
