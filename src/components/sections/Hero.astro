---
import type { Lang } from '../../i18n/translations';
import { useTranslations } from '../../i18n/translations';

interface Props {
  lang: Lang;
}

const { lang } = Astro.props;
const t = useTranslations(lang);
---

<section
  id="hero"
  class="relative w-full h-screen flex flex-col justify-center items-center overflow-hidden"
  style="background-color: var(--color-bg);"
>
  <!-- WebGL Background Canvas -->
  <canvas
    id="hero-canvas"
    class="absolute inset-0 w-full h-full -z-10 hidden lg:block"
  ></canvas>

  <!-- CSS gradient fallback for mobile -->
  <div class="absolute inset-0 -z-10 lg:hidden bg-gradient-to-br from-[var(--color-bg)] via-[var(--color-bg-elevated)] to-[var(--color-bg)]">
    <div class="absolute inset-0 opacity-20" style="background: radial-gradient(ellipse at 30% 50%, rgba(234,78,51,0.15) 0%, transparent 60%)"></div>
  </div>

  <!-- Main content -->
  <div class="relative w-full h-full px-6 md:px-10 flex flex-col justify-center max-w-[2000px] mx-auto">

    <!-- Title â€” centered, dominant -->
    <div class="flex flex-col items-center justify-center">
      <h1
        id="hero-title"
        class="text-display-xl text-center text-[var(--color-text)] select-none overflow-hidden"
        aria-label={t.hero.title}
      >
        {t.hero.title}
      </h1>
    </div>

    <!-- Corner metadata: top -->
    <div class="absolute top-6 md:top-10 left-6 md:left-10 right-6 md:right-10 flex justify-between items-start">
      <!-- Top-left: availability -->
      <div id="hero-corner-tl" class="flex items-center gap-2 opacity-0">
        <span class="w-1.5 h-1.5 rounded-full bg-green-400 animate-pulse"></span>
        <span class="text-mono-xs text-[var(--color-text-subtle)]">{t.hero.available}</span>
      </div>
      <!-- Top-right: location -->
      <div id="hero-corner-tr" class="opacity-0">
        <span class="text-mono-xs text-[var(--color-text-subtle)]">{t.hero.location}</span>
      </div>
    </div>

    <!-- Corner metadata: bottom -->
    <div class="absolute bottom-6 md:bottom-10 left-6 md:left-10 right-6 md:right-10 flex justify-between items-end">
      <!-- Bottom-left: descriptor -->
      <div id="hero-corner-bl" class="opacity-0">
        <span class="text-mono-xs text-[var(--color-text-subtle)]">{t.hero.descriptor}</span>
      </div>
      <!-- Bottom-right: credit -->
      <div id="hero-corner-br" class="opacity-0">
        <span class="text-mono-xs text-[var(--color-text-subtle)]">{t.hero.credit}</span>
      </div>
    </div>
  </div>
</section>

<script>
  import gsap from 'gsap';
  import { SplitText } from 'gsap/SplitText';
  import { ScrollTrigger } from 'gsap/ScrollTrigger';

  gsap.registerPlugin(SplitText, ScrollTrigger);

  function initHero() {
    const titleEl = document.getElementById('hero-title');
    if (!titleEl) return;

    // Split title into characters
    const split = new SplitText(titleEl, {
      type: 'chars',
      charsClass: 'split-char',
    });

    const corners = [
      document.getElementById('hero-corner-tl'),
      document.getElementById('hero-corner-tr'),
      document.getElementById('hero-corner-bl'),
      document.getElementById('hero-corner-br'),
    ].filter(Boolean);

    // Entrance timeline triggered by preloader
    function playEntrance() {
      const tl = gsap.timeline();

      // Characters animate in from below with stagger
      tl.from(split.chars, {
        y: 120,
        opacity: 0,
        rotateX: -80,
        stagger: 0.03,
        duration: 1,
        ease: 'power4.out',
      });

      // Corner labels fade in
      tl.to(corners, {
        opacity: 1,
        duration: 0.8,
        stagger: 0.1,
        ease: 'power2.out',
      }, '-=0.3');
    }

    // Listen for preloader completion
    document.addEventListener('preloader:complete', playEntrance, { once: true });

    // Scroll-driven parallax: characters spread apart
    if (split.chars && split.chars.length > 0) {
      split.chars.forEach((char: HTMLElement, i: number) => {
        const offset = (i - split.chars.length / 2) * 8;
        gsap.to(char, {
          x: offset,
          opacity: 0.3,
          scrollTrigger: {
            trigger: '#hero',
            start: 'top top',
            end: 'bottom top',
            scrub: 1,
          },
        });
      });
    }

    // Fade out hero on scroll
    gsap.to('#hero', {
      opacity: 0,
      scrollTrigger: {
        trigger: '#hero',
        start: '60% top',
        end: 'bottom top',
        scrub: 1,
      },
    });
  }

  // WebGL Hero Shader
  function initHeroShader() {
    if (window.innerWidth < 1024) return;

    const canvas = document.getElementById('hero-canvas') as HTMLCanvasElement;
    if (!canvas) return;

    const gl = canvas.getContext('webgl2');
    if (!gl) return;

    // Resize canvas
    function resize() {
      const dpr = Math.min(window.devicePixelRatio, 2);
      canvas.width = canvas.clientWidth * dpr;
      canvas.height = canvas.clientHeight * dpr;
      gl!.viewport(0, 0, canvas.width, canvas.height);
    }
    resize();
    window.addEventListener('resize', resize);

    // Vertex shader
    const vsSource = `#version 300 es
      in vec4 aPosition;
      void main() {
        gl_Position = aPosition;
      }
    `;

    // Fragment shader - aurora/noise effect
    const fsSource = `#version 300 es
      precision highp float;
      uniform vec2 uResolution;
      uniform float uTime;
      uniform vec2 uMouse;
      uniform vec3 uBaseColor;
      uniform vec3 uAccentColor;
      uniform vec3 uMidColor;
      out vec4 fragColor;

      // Simplex noise
      vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
      vec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
      vec3 permute(vec3 x) { return mod289(((x * 34.0) + 1.0) * x); }

      float snoise(vec2 v) {
        const vec4 C = vec4(0.211324865405187, 0.366025403784439, -0.577350269189626, 0.024390243902439);
        vec2 i = floor(v + dot(v, C.yy));
        vec2 x0 = v - i + dot(i, C.xx);
        vec2 i1;
        i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
        vec4 x12 = x0.xyxy + C.xxzz;
        x12.xy -= i1;
        i = mod289(i);
        vec3 p = permute(permute(i.y + vec3(0.0, i1.y, 1.0)) + i.x + vec3(0.0, i1.x, 1.0));
        vec3 m = max(0.5 - vec3(dot(x0, x0), dot(x12.xy, x12.xy), dot(x12.zw, x12.zw)), 0.0);
        m = m * m;
        m = m * m;
        vec3 x = 2.0 * fract(p * C.www) - 1.0;
        vec3 h = abs(x) - 0.5;
        vec3 ox = floor(x + 0.5);
        vec3 a0 = x - ox;
        m *= 1.79284291400159 - 0.85373472095314 * (a0 * a0 + h * h);
        vec3 g;
        g.x = a0.x * x0.x + h.x * x0.y;
        g.yz = a0.yz * x12.xz + h.yz * x12.yw;
        return 130.0 * dot(m, g);
      }

      void main() {
        vec2 uv = gl_FragCoord.xy / uResolution;
        vec2 mouse = uMouse / uResolution;

        float t = uTime * 0.15;

        // Layered noise
        float n1 = snoise(uv * 2.0 + vec2(t * 0.3, t * 0.2)) * 0.5;
        float n2 = snoise(uv * 4.0 - vec2(t * 0.2, t * 0.4)) * 0.25;
        float n3 = snoise(uv * 8.0 + vec2(t * 0.5, -t * 0.3)) * 0.125;

        float noise = n1 + n2 + n3;

        // Mouse influence - gentle warping
        float mouseDist = length(uv - mouse);
        float mouseInfluence = smoothstep(0.4, 0.0, mouseDist) * 0.15;
        noise += mouseInfluence * snoise(uv * 3.0 + t);

        // Color: subtle accent glow (driven by uniforms)
        vec3 baseColor = uBaseColor;
        vec3 accentColor = uAccentColor;
        vec3 midColor = uMidColor;

        // Aurora-like color mixing
        float colorMix = smoothstep(-0.2, 0.6, noise);
        float accentMix = smoothstep(0.3, 0.8, noise) * 0.12 + mouseInfluence * 0.3;

        vec3 color = mix(baseColor, midColor, colorMix);
        color = mix(color, accentColor, accentMix);

        // Film grain
        float grain = (fract(sin(dot(uv * uTime, vec2(12.9898, 78.233))) * 43758.5453) - 0.5) * 0.03;
        color += grain;

        // Vignette
        float vignette = 1.0 - smoothstep(0.3, 1.2, length(uv - 0.5) * 1.4);
        color *= vignette;

        fragColor = vec4(color, 1.0);
      }
    `;

    // Compile shaders
    function createShader(type: number, source: string) {
      const shader = gl!.createShader(type)!;
      gl!.shaderSource(shader, source);
      gl!.compileShader(shader);
      if (!gl!.getShaderParameter(shader, gl!.COMPILE_STATUS)) {
        console.warn('Shader error:', gl!.getShaderInfoLog(shader));
        gl!.deleteShader(shader);
        return null;
      }
      return shader;
    }

    const vs = createShader(gl.VERTEX_SHADER, vsSource);
    const fs = createShader(gl.FRAGMENT_SHADER, fsSource);
    if (!vs || !fs) return;

    const program = gl.createProgram()!;
    gl.attachShader(program, vs);
    gl.attachShader(program, fs);
    gl.linkProgram(program);

    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
      console.warn('Program error:', gl.getProgramInfoLog(program));
      return;
    }

    gl.useProgram(program);

    // Full-screen quad
    const positions = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]);
    const buffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
    gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);

    const aPosition = gl.getAttribLocation(program, 'aPosition');
    gl.enableVertexAttribArray(aPosition);
    gl.vertexAttribPointer(aPosition, 2, gl.FLOAT, false, 0, 0);

    // Uniforms
    const uResolution = gl.getUniformLocation(program, 'uResolution');
    const uTime = gl.getUniformLocation(program, 'uTime');
    const uMouse = gl.getUniformLocation(program, 'uMouse');
    const uBaseColor = gl.getUniformLocation(program, 'uBaseColor');
    const uAccentColor = gl.getUniformLocation(program, 'uAccentColor');
    const uMidColor = gl.getUniformLocation(program, 'uMidColor');

    // Theme-aware shader colors
    const darkColors = {
      base: [0.04, 0.04, 0.04],
      accent: [0.918, 0.306, 0.2],
      mid: [0.06, 0.06, 0.12],
    };
    const lightColors = {
      base: [0.94, 0.93, 0.91],
      accent: [0.918, 0.306, 0.2],
      mid: [0.92, 0.91, 0.88],
    };

    function setThemeColors(isDark: boolean) {
      const c = isDark ? darkColors : lightColors;
      gl!.uniform3f(uBaseColor, c.base[0], c.base[1], c.base[2]);
      gl!.uniform3f(uAccentColor, c.accent[0], c.accent[1], c.accent[2]);
      gl!.uniform3f(uMidColor, c.mid[0], c.mid[1], c.mid[2]);
    }

    const darkMql = window.matchMedia('(prefers-color-scheme: dark)');
    setThemeColors(darkMql.matches);
    darkMql.addEventListener('change', (e) => setThemeColors(e.matches));

    let mouseX = canvas.width / 2;
    let mouseY = canvas.height / 2;

    canvas.addEventListener('mousemove', (e) => {
      const rect = canvas.getBoundingClientRect();
      const dpr = Math.min(window.devicePixelRatio, 2);
      mouseX = (e.clientX - rect.left) * dpr;
      mouseY = (rect.height - (e.clientY - rect.top)) * dpr;
    });

    let startTime = performance.now();
    let running = true;

    function render() {
      if (!running) return;

      const time = (performance.now() - startTime) / 1000;
      gl!.uniform2f(uResolution, canvas.width, canvas.height);
      gl!.uniform1f(uTime, time);
      gl!.uniform2f(uMouse, mouseX, mouseY);

      gl!.drawArrays(gl!.TRIANGLE_STRIP, 0, 4);
      requestAnimationFrame(render);
    }

    // Visibility observer - pause when not visible
    const observer = new IntersectionObserver(
      (entries) => {
        running = entries[0].isIntersecting;
        if (running) {
          startTime = performance.now() - (performance.now() - startTime);
          render();
        }
      },
      { threshold: 0.1 }
    );
    observer.observe(canvas);

    render();
  }

  initHero();
  initHeroShader();
  document.addEventListener('astro:after-swap', () => {
    initHero();
    initHeroShader();
  });
</script>
