---
import type { Lang } from '../../i18n/translations';
import { useTranslations } from '../../i18n/translations';

interface Props {
  lang: Lang;
}

const { lang } = Astro.props;
const t = useTranslations(lang);
const items = t.testimonials.items;
const totalStr = String(items.length).padStart(2, '0');
---

<section
  id="testimonials"
  class="relative border-t border-[var(--color-border)]"
  style="background-color: var(--color-bg);"
>
  <!-- Scroll height container — creates the scroll distance for panels -->
  <div class="testimonial-scroll-height">

    <!-- Sticky viewport -->
    <div class="sticky top-0 h-screen flex items-center overflow-hidden">

      <!-- Top bar: label + counter -->
      <div class="absolute top-0 left-0 right-0 px-6 md:px-10 pt-24 z-20">
        <div class="flex justify-between items-center">
          <h2 class="text-mono-xs text-[#0A0A0A]">{t.testimonials.label}</h2>
          <span class="text-mono-xs text-[var(--color-text-subtle)]">
            <span id="testimonial-counter-active" style="color: var(--color-accent);">01</span> / {totalStr}
          </span>
        </div>
        <div class="mt-4 w-full h-px bg-[var(--color-text)]" data-line></div>
      </div>

      <!-- Decorative: Background panel index number -->
      <div
        id="testimonial-bg-number"
        class="absolute inset-0 flex items-center justify-center pointer-events-none z-0 select-none hidden md:flex"
        aria-hidden="true"
      >
        <span
          class="text-transparent font-bold leading-none"
          style="font-family: var(--font-display); font-size: clamp(15rem, 30vw, 35rem); -webkit-text-stroke: 1px var(--color-text-faint); letter-spacing: -0.04em;"
        >
          01
        </span>
      </div>

      <!-- Testimonial panels container -->
      <div class="relative w-full px-6 md:px-10 max-w-[1100px] mx-auto z-10 testimonial-panels-container">
        {items.map((item, i) => (
          <div
            class="testimonial-panel absolute top-0 left-0 right-0 bottom-0 flex flex-col items-center justify-center px-6 md:px-10"
            data-panel-index={i}
            data-highlights={JSON.stringify(item.highlights)}
            style={i === 0
              ? `opacity: 1; z-index: ${i}; clip-path: inset(0 0 0 0); background-color: var(--color-bg);`
              : `opacity: 0; z-index: ${i}; clip-path: inset(100% 0 0 0); transform: translateY(100%); background-color: var(--color-bg);`}
          >
            <!-- Quote -->
            <blockquote class="max-w-[900px] w-full">
              <p
                class="testimonial-quote leading-[1.3] text-[var(--color-text)]"
                style={`font-family: var(--font-serif); font-size: clamp(2.25rem, 4vw, 3.5rem); letter-spacing: -0.02em;`}
              >
                &ldquo;{item.quote}&rdquo;
              </p>
            </blockquote>

            <!-- Author -->
            <div class="testimonial-author mt-8 md:mt-12 max-w-[900px] w-full">
              <div class="flex items-center gap-3">
                <span class="w-6 h-px bg-[var(--color-accent)]"></span>
                <span class="text-mono-xs text-[var(--color-text)]">{item.name}</span>
              </div>
              <div class="ml-9">
                <span class="text-mono-xs text-[var(--color-text-subtle)]">{item.role}</span>
              </div>
            </div>
          </div>
        ))}
      </div>

      <!-- Bottom bar: dots + progress -->
      <div class="absolute bottom-0 left-0 right-0 px-6 md:px-10 pb-8 flex justify-between items-center z-20">
        <!-- Dot indicators -->
        <div class="flex items-center gap-2" id="testimonial-dots">
          {items.map((_, i) => (
            <span
              class="testimonial-dot w-2 h-2 rounded-full transition-all duration-500"
              data-dot-index={i}
              style={i === 0
                ? 'background-color: var(--color-accent);'
                : 'background-color: var(--color-text-ghost);'}
            ></span>
          ))}
        </div>

        <!-- Progress bar -->
        <div class="w-32 md:w-48 h-px bg-[var(--color-border-strong)] relative overflow-hidden">
          <div
            id="testimonial-progress"
            class="absolute inset-y-0 left-0 bg-[var(--color-accent)]"
            style="width: 0%; transition: none;"
          ></div>
        </div>
      </div>

    </div>
  </div>
</section>

<style>
  .testimonial-scroll-height {
    height: 300vh;
  }

  @media (min-width: 768px) {
    .testimonial-scroll-height {
      height: 350vh;
    }
  }

  @media (min-width: 1024px) {
    .testimonial-scroll-height {
      height: 400vh;
    }
  }

  .testimonial-panels-container {
    min-height: 60vh;
    padding-top: 25vh;
    padding-bottom: 10vh;
  }

  @media (min-width: 768px) {
    .testimonial-panels-container {
      padding-top: 0;
      padding-bottom: 0;
    }
  }

  .testimonial-panel {
    will-change: transform, clip-path;
  }

  .quote-word {
    display: inline-block;
  }

  .quote-char {
    display: inline-block;
    will-change: opacity;
  }
</style>

<script>
  import gsap from 'gsap';
  import { SplitText } from 'gsap/SplitText';
  import { ScrollTrigger } from 'gsap/ScrollTrigger';

  gsap.registerPlugin(SplitText, ScrollTrigger);

  let cleanupFn: (() => void) | null = null;

  function initTestimonials() {
    cleanupFn?.();
    cleanupFn = null;

    const section = document.getElementById('testimonials');
    if (!section) return;

    const panels = section.querySelectorAll('.testimonial-panel');
    const counterActiveEl = document.getElementById('testimonial-counter-active');
    const progressEl = document.getElementById('testimonial-progress');
    const bgNumberEl = document.getElementById('testimonial-bg-number');
    const bgNumberSpan = bgNumberEl?.querySelector('span');
    const dots = section.querySelectorAll('.testimonial-dot');
    const line = section.querySelector('[data-line]');
    const totalPanels = panels.length;
    const scrollTriggers: ScrollTrigger[] = [];

    if (totalPanels === 0) return;

    // Check reduced motion preference
    const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;

    // Split each panel's quote into words and chars
    const splits: any[] = [];
    panels.forEach((panel, i) => {
      const quoteEl = panel.querySelector('.testimonial-quote');
      if (!quoteEl) return;

      const highlights = JSON.parse((panel as HTMLElement).dataset.highlights || '[]') as string[];

      const split = new SplitText(quoteEl, {
        type: 'words,chars',
        wordsClass: 'quote-word',
        charsClass: 'quote-char',
      });

      // Mark highlight words with accent color from the start
      split.words.forEach((word: HTMLElement) => {
        const text = word.textContent?.replace(/[^a-zA-ZąćęłńóśźżĄĆĘŁŃÓŚŹŻ\-]/g, '') || '';
        if (highlights.some((h: string) => text.toLowerCase() === h.toLowerCase())) {
          word.dataset.highlight = 'true';
          word.style.color = 'var(--color-accent)';
        }
      });

      split.chars.forEach((char: HTMLElement) => {
        if (prefersReducedMotion) {
          char.style.opacity = '1';
        } else {
          char.style.opacity = '0.06';
        }
      });

      splits.push(split);
    });

    if (!prefersReducedMotion && line) {
      gsap.set(line, { scaleX: 0, transformOrigin: 'left' });
      const lineTween = gsap.to(line, {
        scaleX: 1,
        duration: 0.8,
        ease: 'power3.out',
        scrollTrigger: {
          trigger: section,
          start: 'top 85%',
          once: true,
        },
      });
      if (lineTween.scrollTrigger) scrollTriggers.push(lineTween.scrollTrigger);
    }

    // ===== MAIN SCROLL TRIGGER =====
    scrollTriggers.push(ScrollTrigger.create({
      trigger: section,
      start: 'top top',
      end: 'bottom bottom',
      scrub: 1,
      onUpdate: (self) => {
        const progress = self.progress;
        const panelProgress = progress * totalPanels;
        const activePanelIndex = Math.min(totalPanels - 1, Math.floor(panelProgress));
        const panelLocalProgress = panelProgress - activePanelIndex;

        // Update progress bar
        if (progressEl) {
          progressEl.style.width = `${progress * 100}%`;
        }

        // Update counter
        if (counterActiveEl) {
          counterActiveEl.textContent = String(activePanelIndex + 1).padStart(2, '0');
        }

        // Update background number
        if (bgNumberSpan) {
          bgNumberSpan.textContent = String(activePanelIndex + 1).padStart(2, '0');
        }

        // Update dot indicators
        dots.forEach((dot, i) => {
          const el = dot as HTMLElement;
          if (i === activePanelIndex) {
            el.style.backgroundColor = 'var(--color-accent)';
            el.style.transform = 'scale(1.3)';
          } else {
            el.style.backgroundColor = 'var(--color-text-ghost)';
            el.style.transform = 'scale(1)';
          }
        });

        // Panel visibility and word reveal — stacking card slide-over
        const crossfadeStart = 0.7; // Last 30% of panel scroll = transition zone

        panels.forEach((panel, i) => {
          const el = panel as HTMLElement;
          const authorEl = el.querySelector('.testimonial-author') as HTMLElement;
          const split = splits[i];

          // Z-index stacking: later panels sit on top
          el.style.zIndex = String(i);

          if (i < activePanelIndex) {
            // Previous panels — visible behind the stack with subtle upward drift
            el.style.opacity = '1';
            const depth = activePanelIndex - i;
            const scale = prefersReducedMotion ? 1 : 1 - Math.min(0.05, depth * 0.015);
            el.style.transform = `translateY(${-depth * 15}px) scale(${scale})`;
            el.style.clipPath = 'inset(0 0 0 0)';
            el.style.pointerEvents = 'none';

            // All chars fully revealed on passed panels
            if (split && !prefersReducedMotion) {
              split.chars.forEach((char: HTMLElement) => {
                char.style.opacity = '1';
              });
              split.words.forEach((word: HTMLElement) => {
                if (word.dataset.highlight === 'true') {
                  word.style.color = 'var(--color-accent)';
                }
              });
            }
            if (authorEl) {
              authorEl.style.opacity = '1';
              authorEl.style.transform = 'translateY(0)';
              authorEl.style.transition = 'none';
            }
          } else if (i === activePanelIndex) {
            // Current panel — fully visible
            el.style.opacity = '1';
            el.style.clipPath = 'inset(0 0 0 0)';
            el.style.pointerEvents = 'auto';

            // Slight upward drift as next panel starts covering
            if (panelLocalProgress > crossfadeStart && i < totalPanels - 1) {
              const drift = (panelLocalProgress - crossfadeStart) / (1 - crossfadeStart);
              const scale = prefersReducedMotion ? 1 : 1 - drift * 0.01;
              el.style.transform = `translateY(${-15 * drift}px) scale(${scale})`;
            } else {
              el.style.transform = 'translateY(0) scale(1)';
            }

            // Char reveal based on local progress (first 70% of panel scroll)
            // Uses a smooth gradient: chars near the frontier get intermediate opacity
            if (split && !prefersReducedMotion) {
              const revealPhase = Math.min(1, panelLocalProgress / 0.65);
              const totalChars = split.chars.length;
              const revealCenter = revealPhase * totalChars;
              const spread = 8; // chars over which opacity transitions from 0 → 1

              split.chars.forEach((char: HTMLElement, ci: number) => {
                const t = (revealCenter - ci + spread) / spread; // 1 = fully revealed, 0 = ghost
                const clamped = Math.min(1, Math.max(0, t));
                const opacity = 0.06 + clamped * 0.94; // 0.06 → 1
                char.style.opacity = String(opacity);
              });

              // Apply highlight color — always on so it reveals with opacity
              split.words.forEach((word: HTMLElement) => {
                if (word.dataset.highlight === 'true') {
                  word.style.color = 'var(--color-accent)';
                }
              });
            }

            // Author always visible on active panel
            if (authorEl) {
              authorEl.style.opacity = '1';
              authorEl.style.transform = 'translateY(0)';
            }
          } else if (i === activePanelIndex + 1 && panelLocalProgress > crossfadeStart) {
            // Next panel — sliding up from below, covering the current one
            const reveal = (panelLocalProgress - crossfadeStart) / (1 - crossfadeStart); // 0→1
            el.style.opacity = '1';
            const scale = prefersReducedMotion ? 1 : 1.02 - reveal * 0.02;
            el.style.transform = `translateY(${(1 - reveal) * 100}%) scale(${scale})`;
            el.style.clipPath = `inset(${(1 - reveal) * 100}% 0 0 0)`;
            el.style.pointerEvents = 'none';

            // Reset chars on incoming panel
            if (split && !prefersReducedMotion) {
              split.chars.forEach((char: HTMLElement) => {
                char.style.opacity = '0.06';
              });
            }
          } else {
            // Future panels — hidden below
            el.style.opacity = '0';
            const scale = prefersReducedMotion ? 1 : 1.02;
            el.style.transform = `translateY(100%) scale(${scale})`;
            el.style.clipPath = 'inset(100% 0 0 0)';
            el.style.pointerEvents = 'none';

            // Reset char opacity for future panels
            if (split && !prefersReducedMotion) {
              split.chars.forEach((char: HTMLElement) => {
                char.style.opacity = '0.06';
              });
            }
          }
        });
      },
    }));

    // ===== BACKGROUND NUMBER PARALLAX =====
    if (bgNumberEl && !prefersReducedMotion) {
      const parallaxTween = gsap.to(bgNumberEl, {
        y: -60,
        scrollTrigger: {
          trigger: section,
          start: 'top bottom',
          end: 'bottom top',
          scrub: 1,
        },
      });
      if (parallaxTween.scrollTrigger) scrollTriggers.push(parallaxTween.scrollTrigger);
    }

    cleanupFn = () => {
      scrollTriggers.forEach((st) => st.kill());
      splits.forEach((split) => split.revert());
    };
  }

  initTestimonials();
  document.addEventListener('astro:after-swap', initTestimonials);
</script>
