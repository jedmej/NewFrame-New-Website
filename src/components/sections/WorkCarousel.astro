---
import type { Lang } from '../../i18n/translations';
import { useTranslations } from '../../i18n/translations';
import { projects as allProjects } from '../../lib/projects';

interface Props {
  lang: Lang;
}

const { lang } = Astro.props;
const t = useTranslations(lang);

const projects = allProjects.map((p) => ({
  name: p.name,
  image: p.image,
  category: p.category,
  url: p.url,
}));
---

<section
  id="work"
  class="relative"
  style="background-color: var(--color-bg-dark);"
>
  <!-- Entrance wipe: cream overlay clips away to reveal dark section -->
  <div id="work-wipe-in" class="absolute top-0 left-0 right-0 h-screen z-30 pointer-events-none"
       style="background-color: var(--color-bg);"></div>

  <!-- Section label -->
  <div class="px-6 md:px-10 pt-32 md:pt-48 pb-8 max-w-[1400px] mx-auto">
    <div class="flex justify-between items-end">
      <h2 class="text-mono-xs text-white">{t.work.label}</h2>
      <span id="work-counter" class="text-mono-xs text-white/40">01 {t.work.counter} {String(projects.length).padStart(2, '0')}</span>
    </div>
    <div class="mt-4 w-full h-px bg-white/20" data-line></div>
  </div>

  <!-- Carousel container -->
  <div id="carousel-section" class="relative h-[350vh]">
    <!-- Sticky container -->
    <div class="sticky top-0 h-screen overflow-hidden">
      <!-- Progressive blur top -->
      <div class="absolute top-0 left-0 right-0 h-32 z-10 pointer-events-none" style="background: linear-gradient(to bottom, var(--color-bg-dark), transparent);"></div>

      <!-- Three.js canvas -->
      <canvas
        id="carousel-canvas"
        class="absolute inset-0 w-full h-full"
        role="img"
        aria-label={t.work.carouselLabel}
        data-projects={JSON.stringify(projects)}
        data-lang={lang}
      ></canvas>

      <!-- WebGL fallback (hidden by default, shown only when WebGL unavailable) -->
      <div id="carousel-fallback" class="absolute inset-0 hidden overflow-hidden">
        <div class="flex items-center justify-center h-full px-6 gap-4">
          {projects.map((p) => (
            <a href={p.url !== '#' ? p.url : undefined} target="_blank" rel="noopener noreferrer"
               class="block w-[200px] h-[260px] md:w-[280px] md:h-[360px] flex-shrink-0 overflow-hidden rounded-sm">
              <img src={p.image} alt={p.name} class="w-full h-full object-cover" loading="lazy" />
            </a>
          ))}
        </div>
      </div>

      <!-- Project name overlay -->
      <div
        id="project-name-overlay"
        class="absolute inset-0 flex items-center justify-center pointer-events-none z-20"
        style="mix-blend-mode: difference;"
      >
        <h2
          id="project-name-text"
          class="text-display-xl text-white text-center select-none"
        >
          {projects[0].name}
        </h2>
      </div>

      <!-- Bottom gradient -->
      <div class="absolute bottom-0 left-0 right-0 h-32 z-10 pointer-events-none" style="background: linear-gradient(to top, var(--color-bg-dark), transparent);"></div>

      <!-- Exit wipe: cream overlay clips in from top to cover dark section on exit -->
      <div id="work-wipe-out" class="absolute inset-0 z-30 pointer-events-none"
           style="background-color: var(--color-bg); clip-path: inset(100% 0% 0% 0%);"></div>
    </div>
  </div>
</section>

<script>
  import { Scene, PerspectiveCamera, WebGLRenderer, TextureLoader, PlaneGeometry, MeshBasicMaterial, Mesh, Raycaster, Vector2, SRGBColorSpace, DoubleSide } from 'three';
  import type { Mesh as MeshType } from 'three';
  import gsap from 'gsap';
  import { ScrollTrigger } from 'gsap/ScrollTrigger';

  gsap.registerPlugin(ScrollTrigger);

  let cleanupFn: (() => void) | null = null;

  function initCarousel() {
    cleanupFn?.();
    cleanupFn = null;

    const section = document.getElementById('work');
    const canvas = document.getElementById('carousel-canvas') as HTMLCanvasElement;
    const nameText = document.getElementById('project-name-text');
    const counterEl = document.getElementById('work-counter');
    const line = section?.querySelector('[data-line]');
    if (!canvas || !section) return;

    // WebGL availability check
    const testCanvas = document.createElement('canvas');
    const gl = testCanvas.getContext('webgl') || testCanvas.getContext('experimental-webgl');
    if (!gl) {
      const fallback = document.getElementById('carousel-fallback');
      if (fallback) fallback.classList.remove('hidden');
      canvas.style.display = 'none';
      return;
    }

    const ac = new AbortController();
    const { signal } = ac;

    const projects = JSON.parse(canvas.dataset.projects || '[]');
    const isMobile = window.innerWidth < 768;
    const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;

    let lineTrigger: ScrollTrigger | null = null;
    let wipeTrigger: ScrollTrigger | null = null;
    let wipeOutTrigger: ScrollTrigger | null = null;

    // Entrance wipe — cream overlay clips away to reveal dark section
    const wipeEl = document.getElementById('work-wipe-in');
    if (wipeEl && !prefersReducedMotion) {
      const wipeTween = gsap.fromTo(wipeEl,
        { clipPath: 'inset(0% 0% 0% 0%)' },
        {
          clipPath: 'inset(0% 0% 100% 0%)',
          ease: 'none',
          scrollTrigger: {
            trigger: section,
            start: 'top bottom',
            end: 'top 10%',
            scrub: true,
          },
        }
      );
      if (wipeTween.scrollTrigger) wipeTrigger = wipeTween.scrollTrigger;
    } else if (wipeEl) {
      wipeEl.style.display = 'none';
    }

    // Exit wipe — cream overlay clips in from top as section exits
    const wipeOutEl = document.getElementById('work-wipe-out');
    if (wipeOutEl && !prefersReducedMotion) {
      const wipeOutTween = gsap.fromTo(wipeOutEl,
        { clipPath: 'inset(100% 0% 0% 0%)' },
        {
          clipPath: 'inset(0% 0% 0% 0%)',
          ease: 'none',
          scrollTrigger: {
            trigger: '#carousel-section',
            start: 'bottom bottom',
            end: 'bottom 20%',
            scrub: true,
          },
        }
      );
      if (wipeOutTween.scrollTrigger) wipeOutTrigger = wipeOutTween.scrollTrigger;
    } else if (wipeOutEl) {
      wipeOutEl.style.display = 'none';
    }

    if (!prefersReducedMotion && line) {
      gsap.set(line, { scaleX: 0, transformOrigin: 'left' });
      const lineTween = gsap.to(line, {
        scaleX: 1,
        duration: 0.8,
        ease: 'power3.out',
        scrollTrigger: {
          trigger: section,
          start: 'top 85%',
          once: true,
        },
      });
      if (lineTween.scrollTrigger) lineTrigger = lineTween.scrollTrigger;
    }

    // Scene setup
    const scene = new Scene();
    const camera = new PerspectiveCamera(60, canvas.clientWidth / canvas.clientHeight, 0.1, 1000);
    camera.position.set(0, 0, 5);

    let renderer: WebGLRenderer;
    try {
      renderer = new WebGLRenderer({
        canvas,
        alpha: true,
        antialias: !isMobile,
        powerPreference: isMobile ? 'low-power' : 'high-performance',
      });
    } catch {
      const fallback = document.getElementById('carousel-fallback');
      if (fallback) fallback.classList.remove('hidden');
      canvas.style.display = 'none';
      return;
    }

    const dpr = Math.min(window.devicePixelRatio, isMobile ? 1.5 : 2);
    renderer.setPixelRatio(dpr);
    renderer.setSize(canvas.clientWidth, canvas.clientHeight);
    renderer.outputColorSpace = SRGBColorSpace;

    // Load textures
    const textureLoader = new TextureLoader();
    const meshes: MeshType[] = [];
    const cardWidth = isMobile ? 2.24 : 3.5;
    const cardHeight = isMobile ? 3.04 : 4.5;
    const radius = isMobile ? 4 : 5.5;
    const projectCount = projects.length;

    projects.forEach((project: any, i: number) => {
      const geometry = new PlaneGeometry(cardWidth, cardHeight, 1, 1);

      const material = new MeshBasicMaterial({
        color: 0x333333,
        side: DoubleSide,
      });

      // Load texture asynchronously
      textureLoader.load(project.image, (texture) => {
        if (destroyed) { texture.dispose(); return; }
        texture.colorSpace = SRGBColorSpace;

        // Calculate UV scaling for cover behavior
        const imgAspect = texture.image.width / texture.image.height;
        const planeAspect = cardWidth / cardHeight;
        let scaleX = 1, scaleY = 1;
        if (imgAspect > planeAspect) {
          scaleX = planeAspect / imgAspect;
        } else {
          scaleY = imgAspect / planeAspect;
        }

        texture.repeat.set(scaleX, scaleY);
        texture.offset.set((1 - scaleX) / 2, (1 - scaleY) / 2);

        material.map = texture;
        material.color.set(0xffffff);
        material.needsUpdate = true;
      });

      const mesh = new Mesh(geometry, material);

      // Position in a spiral/tornado arrangement
      const angle = (i / projectCount) * Math.PI * 2;
      mesh.position.x = Math.sin(angle) * radius;
      mesh.position.z = Math.cos(angle) * radius - radius;
      mesh.position.y = 0;

      // Face center
      mesh.lookAt(0, mesh.position.y, 0);

      mesh.userData = { index: i, baseAngle: angle, project };
      meshes.push(mesh);
      scene.add(mesh);
    });

    // Scroll-driven rotation
    let targetRotation = 0;
    let currentRotation = 0;
    let currentProjectIndex = 0;

    const scrollTriggerInstance = ScrollTrigger.create({
      trigger: '#carousel-section',
      start: 'top top',
      end: 'bottom bottom',
      scrub: 0.3,
      onUpdate: (self) => {
        targetRotation = -(self.progress * Math.PI * 2 * (projectCount - 1) / projectCount);

        // Update project index (mapped to reduced rotation range, offset to sync with lerp)
        const adjustedProgress = self.progress * (projectCount - 1);
        const newIndex = Math.min(
          projectCount - 1,
          Math.floor(adjustedProgress + 0.4)
        );

        if (newIndex !== currentProjectIndex && nameText && counterEl) {
          currentProjectIndex = newIndex;
          const project = projects[currentProjectIndex];

          if (prefersReducedMotion) {
            nameText.textContent = project.name;
            counterEl.textContent = `${String(currentProjectIndex + 1).padStart(2, '0')} of ${String(projectCount).padStart(2, '0')}`;
          } else {
            gsap.killTweensOf(nameText);
            gsap.killTweensOf(counterEl);

            gsap.to(nameText, {
              y: -12,
              opacity: 0,
              duration: 0.15,
              ease: 'power2.in',
              onComplete: () => {
                nameText.textContent = project.name;
                gsap.fromTo(nameText,
                  { y: 16, opacity: 0 },
                  { y: 0, opacity: 1, duration: 0.4, ease: 'power3.out' }
                );
              },
            });

            gsap.to(counterEl, {
              opacity: 0,
              duration: 0.15,
              ease: 'power2.in',
              onComplete: () => {
                counterEl.textContent = `${String(currentProjectIndex + 1).padStart(2, '0')} of ${String(projectCount).padStart(2, '0')}`;
                gsap.to(counterEl, { opacity: 1, duration: 0.3, ease: 'power2.out' });
              },
            });
          }
        }
      },
    });

    // Mouse parallax
    let mouseX = 0;
    let mouseY = 0;

    canvas.addEventListener('mousemove', (e) => {
      const rect = canvas.getBoundingClientRect();
      mouseX = ((e.clientX - rect.left) / rect.width - 0.5) * 2;
      mouseY = ((e.clientY - rect.top) / rect.height - 0.5) * 2;
    }, { signal });

    // Hover detection
    const raycaster = new Raycaster();
    const pointer = new Vector2();
    let hoveredMesh: MeshType | null = null;

    canvas.addEventListener('mousemove', (e) => {
      const rect = canvas.getBoundingClientRect();
      pointer.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
      pointer.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;

      raycaster.setFromCamera(pointer, camera);
      const intersects = raycaster.intersectObjects(meshes);

      if (intersects.length > 0) {
        const mesh = intersects[0].object as MeshType;
        if (hoveredMesh !== mesh) {
          // Reset previous
          if (hoveredMesh) {
            gsap.to(hoveredMesh.scale, { x: 1, y: 1, z: 1, duration: 0.25, ease: 'power2.out' });
          }
          hoveredMesh = mesh;
          gsap.to(mesh.scale, { x: 1.08, y: 1.08, z: 1.08, duration: 0.25, ease: 'power2.out' });
          canvas.style.cursor = 'pointer';
        }
      } else {
        if (hoveredMesh) {
          gsap.to(hoveredMesh.scale, { x: 1, y: 1, z: 1, duration: 0.25, ease: 'power2.out' });
          hoveredMesh = null;
          canvas.style.cursor = 'default';
        }
      }
    }, { signal });

    // Click to navigate to external site
    canvas.addEventListener('click', () => {
      if (hoveredMesh) {
        const project = hoveredMesh.userData.project;
        if (project?.url && project.url !== '#') {
          window.open(project.url, '_blank', 'noopener');
        }
      }
    }, { signal });

    // Render loop
    let destroyed = false;
    let running = true;
    const fps = isMobile ? 30 : 60;
    const interval = 1000 / fps;
    let lastTime = 0;
    let rafId: number;

    function animate(time: number) {
      if (destroyed) return;

      if (!running) {
        rafId = requestAnimationFrame(animate);
        return;
      }

      const delta = time - lastTime;
      if (delta < interval) {
        rafId = requestAnimationFrame(animate);
        return;
      }
      lastTime = time - (delta % interval);

      // Smooth rotation — higher lerp for snappier feel
      currentRotation += (targetRotation - currentRotation) * 0.15;

      // Update mesh positions + depth-based focus
      meshes.forEach((mesh) => {
        const baseAngle = mesh.userData.baseAngle;
        const angle = baseAngle + currentRotation;

        mesh.position.x = Math.sin(angle) * radius;
        mesh.position.z = Math.cos(angle) * radius - radius;

        // Depth-of-field: cards closer to camera are sharp, far cards fade out
        const depth = mesh.position.z;
        const normalizedDepth = Math.max(0, Math.min(1, -depth / (2 * radius)));
        const focusFalloff = 1 - normalizedDepth * normalizedDepth;

        const mat = mesh.material as MeshBasicMaterial;
        mat.opacity = 0.15 + focusFalloff * 0.85;
        mat.transparent = true;

        // Dim color for far cards to simulate defocus
        const brightness = 0.3 + focusFalloff * 0.7;
        if (mat.map) {
          mat.color.setRGB(brightness, brightness, brightness);
        }

        // Mouse parallax tilt
        mesh.rotation.y = -angle + Math.PI + mouseX * 0.07;
        mesh.rotation.x = mouseY * 0.04;
      });

      renderer.render(scene, camera);
      rafId = requestAnimationFrame(animate);
    }

    // Visibility observer
    const observer = new IntersectionObserver(
      (entries) => { running = entries[0].isIntersecting; },
      { threshold: 0.1 }
    );
    observer.observe(canvas);

    rafId = requestAnimationFrame(animate);

    // Resize handler
    const handleResize = () => {
      camera.aspect = canvas.clientWidth / canvas.clientHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(canvas.clientWidth, canvas.clientHeight);
    };

    let resizeTimeout: ReturnType<typeof setTimeout>;
    window.addEventListener('resize', () => {
      clearTimeout(resizeTimeout);
      resizeTimeout = setTimeout(handleResize, 100);
    }, { signal });

    // Cleanup function for view transitions
    cleanupFn = () => {
      destroyed = true;
      cancelAnimationFrame(rafId);
      clearTimeout(resizeTimeout);
      ac.abort();
      observer.disconnect();
      scrollTriggerInstance.kill();
      lineTrigger?.kill();
      wipeTrigger?.kill();
      wipeOutTrigger?.kill();

      // Dispose Three.js resources
      meshes.forEach((mesh) => {
        mesh.geometry.dispose();
        const mat = mesh.material as MeshBasicMaterial;
        mat.map?.dispose();
        mat.dispose();
      });
      scene.clear();
      renderer.dispose();
      renderer.forceContextLoss();
    };
  }

  initCarousel();
  document.addEventListener('astro:after-swap', initCarousel);
</script>
