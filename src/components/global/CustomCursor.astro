---
---

<div id="custom-cursor" class="hidden lg:block">
  <div id="cursor-dot" class="cursor-dot"></div>
  <div id="cursor-circle" class="cursor-circle"></div>
  <span id="cursor-label" class="cursor-label"></span>
</div>

<script>
  import gsap from 'gsap';

  let cleanupFn: (() => void) | null = null;

  function initCursor() {
    cleanupFn?.();
    cleanupFn = null;

    const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;

    const isTouch = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
    if (isTouch || window.innerWidth < 1024) return;

    const dot = document.getElementById('cursor-dot');
    const circle = document.getElementById('cursor-circle');
    const label = document.getElementById('cursor-label');
    if (!dot || !circle || !label) return;

    const ac = new AbortController();
    const { signal } = ac;

    let mouseX = 0;
    let mouseY = 0;
    let dotX = 0;
    let dotY = 0;
    let circleX = 0;
    let circleY = 0;
    let destroyed = false;
    let rafId: number;

    // Hide default cursor
    document.body.style.cursor = 'none';

    document.addEventListener('mousemove', (e) => {
      mouseX = e.clientX;
      mouseY = e.clientY;
    }, { signal });

    function animate() {
      if (destroyed) return;

      // Dot follows immediately with slight smoothing
      dotX += (mouseX - dotX) * 0.2;
      dotY += (mouseY - dotY) * 0.2;
      dot.style.transform = `translate(${dotX - 4}px, ${dotY - 4}px)`;

      // Circle follows with more lag
      circleX += (mouseX - circleX) * 0.08;
      circleY += (mouseY - circleY) * 0.08;
      circle.style.transform = `translate(${circleX - 20}px, ${circleY - 20}px)`;

      // Label follows circle
      label.style.transform = `translate(${circleX + 24}px, ${circleY - 6}px)`;

      rafId = requestAnimationFrame(animate);
    }
    rafId = requestAnimationFrame(animate);

    // Handle hover states
    const interactiveElements = document.querySelectorAll('a, button, [data-cursor]');

    interactiveElements.forEach((el) => {
      el.addEventListener('mouseenter', () => {
        circle.classList.add('is-hovering');
        const cursorType = (el as HTMLElement).dataset.cursor;
        if (cursorType) {
          label.textContent = cursorType;
          label.style.opacity = '1';
        }
      }, { signal });
      el.addEventListener('mouseleave', () => {
        circle.classList.remove('is-hovering');
        label.style.opacity = '0';
        label.textContent = '';
      }, { signal });
    });

    // Magnetic hover for premium CTA feel
    const magneticItems = document.querySelectorAll<HTMLElement>('[data-magnetic]');
    magneticItems.forEach((item) => {
      const strength = Number(item.dataset.magnetic || '0.3');
      const xTo = gsap.quickTo(item, 'x', { duration: 0.4, ease: 'power3.out' });
      const yTo = gsap.quickTo(item, 'y', { duration: 0.4, ease: 'power3.out' });
      let bounds: DOMRect | null = null;

      const handleEnter = () => {
        bounds = item.getBoundingClientRect();
      };

      const handleMove = (e: MouseEvent) => {
        if (!bounds) bounds = item.getBoundingClientRect();
        const relX = e.clientX - bounds.left - bounds.width / 2;
        const relY = e.clientY - bounds.top - bounds.height / 2;
        xTo(relX * strength);
        yTo(relY * strength);
      };

      const handleLeave = () => {
        xTo(0);
        yTo(0);
      };

      item.addEventListener('mouseenter', handleEnter, { signal });
      item.addEventListener('mousemove', handleMove, { signal });
      item.addEventListener('mouseleave', handleLeave, { signal });
    });

    // Confetti on click (skip if reduced motion preferred)
    let lastConfettiTime = 0;
    if (!prefersReducedMotion) {
      document.addEventListener('click', (e) => {
        const now = Date.now();
        if (now - lastConfettiTime < 200) return;
        lastConfettiTime = now;
        createConfetti(e.clientX, e.clientY);
      }, { signal });
    }

    cleanupFn = () => {
      destroyed = true;
      cancelAnimationFrame(rafId);
      ac.abort();
      document.body.style.cursor = '';
      document.querySelectorAll('.confetti-particle').forEach(el => el.remove());
      magneticItems.forEach((item) => {
        item.style.transform = '';
      });
    };
  }

  function createConfetti(x: number, y: number) {
    const style = getComputedStyle(document.documentElement);
    const textColor = style.getPropertyValue('--color-text').trim() || '#ffffff';
    const bgColor = style.getPropertyValue('--color-bg').trim() || '#0a0a0a';
    const colors = ['#DA382E', textColor, bgColor, '#6b6b6b'];
    const count = 10;

    for (let i = 0; i < count; i++) {
      const particle = document.createElement('div');
      particle.className = 'confetti-particle';
      particle.style.cssText = `
        position: fixed;
        width: 4px;
        height: 4px;
        background: ${colors[Math.floor(Math.random() * colors.length)]};
        pointer-events: none;
        z-index: 10000;
        left: ${x}px;
        top: ${y}px;
      `;
      document.body.appendChild(particle);

      const angle = (Math.PI * 2 * i) / count + Math.random() * 0.5;
      const distance = 40 + Math.random() * 60;
      const tx = Math.cos(angle) * distance;
      const ty = Math.sin(angle) * distance;

      particle.animate(
        [
          { transform: 'translate(0, 0) scale(1)', opacity: 1 },
          { transform: `translate(${tx}px, ${ty}px) scale(0)`, opacity: 0 },
        ],
        {
          duration: 500 + Math.random() * 200,
          easing: 'cubic-bezier(0.16, 1, 0.3, 1)',
        }
      ).onfinish = () => particle.remove();
    }
  }

  initCursor();
  document.addEventListener('astro:after-swap', initCursor);
</script>
